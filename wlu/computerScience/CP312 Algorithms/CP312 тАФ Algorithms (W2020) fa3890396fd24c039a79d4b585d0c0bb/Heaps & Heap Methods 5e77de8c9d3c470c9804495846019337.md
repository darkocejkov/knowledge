# Heaps & Heap Methods

Heaps are *binary* *tree* structures that maintain a child/parent relationship between nodes. They are commonly implemented within *arrays* because we have concrete formulae to establish the child/parent relation with indices of elements. The *binary* part refers to the maximum amount of children any node can have, which is 2.

Heaps come in two flavors:

- Max-heap
- Min-heap

Max-heaps are those in which the value of the *parent* node is always larger than any of its child nodes.

Min-heaps are the opposite, in which values of the *parent* node are *smaller* than any its child nodes.

![https://i.imgur.com/1mghTRv.png](https://i.imgur.com/1mghTRv.png)

In order for any heap-based algorithms to work, we must continue to constrain changes to always satisfy the rule of heaps. Any inserted values must end up in their correct position in relation to the children and parent nodes, and any values that are deleted must have existing nodes reform to satisfy the min/max quality of the heap.

Heaps that satisfy the max/min quality are not perfectly sorted, as the children of any *i*th node may not be sorted in relation to each other. This is apparent when we convert tree-based heaps to array-based.

In order to convert, we start from the root node as the first element, and continue down a level, from left â†’ right inserting the nodes as elements in the array.

<aside>
ðŸ’¡ Min-heap = [1, 3, 2, 4, 6, 5]
Max-heap = [6, 5, 3, 4, 2, 1]

</aside>

We can see that in the min-heap, 3 & 2 are children of 1, and children of 3 come before the children of 2. This is how the formula that maintains the relationships work:

<aside>
ðŸ’¡ Parent(i) = $\lfloor i/2 \rfloor$

</aside>

<aside>
ðŸ’¡ Leftchild(i) = $2i$

</aside>

<aside>
ðŸ’¡ Rightchild(i) = $2i +1$

</aside>

â†’ We can obtain the index of any node's parent by using that node's index itself, as we floor the division of that node's index by 2.

â†’ Because we are dealing with array of finite size, we know that some nodes have no parent (such as the root) or no children (such as the leaves) since the result of these formula would result in integers out of the bounds of the array.

---

# Methods

The main methods utilized in any heap structures are done to:

- Create Heap
- Add Elements
- Extract Elements

Any method that manipulates the heap must conform the new order of elements to satisfy the min/max quality of the heap, otherwise we do not have a heap.

## Creation

A heap is defined by its min/max quality, so any array can be a heap as long as it satisfies it. To create a heap, we can **heapify** an array. In example, we will be creating functions to *max-heapify* arrays. 

Max-heapify uses *recursion* to bubble down incorrect parent nodes down into their correct positions. It assumes that the child subtrees of the parent node in question are *both valid max heap*s*.*

In any single recursion, we do a simple swap between the parent node and a child that is larger than both the parent, and the *other* child.

The bubbling down occurs when we check if the parent swapped into its correct position, by checking if it has any children that are larger than it again, and we continue.

```python
maxheapify(A, i, n):
		#i = current index
		#n = total # elements in heap
		l = left(i)
		r = right(i)
	
		if( l <= n and A[l] > A[i] ):
				largest = l
		else:
				largest = i

		if( r <= n and A[r] > A[largest] ):
				largest = r

		if( largest != i ):
				swap(A[i], A[largest])
				maxheapify(A, largest, n)
```

â†’ This is a simple function given an array, the index *i* which is the violating index, and the total number of elements in the array. We do simple checks on index *i*'s children to see which is bigger, and if one of *i*'s children is bigger, then we swap and recurse on the swapped index.

However, maxheapify only bubbles down on the index it is given. Given an unordered array, this would only solve few elements into their maxheap positions. 

```python
buildmaxheap(A, n):
		for( i = floor(n/2) to 1 ):
				maxheapify(A, i, n)			
```

â†’ an iterative solution to building a maxheap from an unordered array.

â†’ we only iterate from the middle index down to 1 because we know that any elements above the midpoint are children nodes that possess no children themselves.

â†’ we start at the last node that has a child, and progress from right to left.

## Insertion & Deletion

Once we possess an array that satisfies heap qualities, we can manipulate the heap by either inserting new nodes or extracting/deleting existing ones.

**Insertion** is very simple, as we simply append the new node as the last element in the array, and it becomes the child of the last parent. We then call *maxheapify* on its parent node to see if it still satisfies the qualities. When the new node violates qualities, still heapify will bubble it up into its correct position.

**Deletion** can only occur on the root node of a heap, we cannot delete nor extract nodes that are not the root node. To do this, we swap the root node with the last element. With the root node now being a child node with no children, we can simply remove it from the array. The swapped node at the new root will violate heap qualities, and thus we perform a recursive maxheapify to bubble up the correct root node, and bubble down the incorrect root.